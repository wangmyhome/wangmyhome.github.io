## 一、前述

### 1、该规范适用范围

- 领域为业务领域

### 2、该规范以《领域驱动设计：软件核心复杂性应对之道》（Eric Evans著）为讨论依据和基础（下称DDD原著）

- 大部分相同的定义和概念，不重复论述
- 本规范作为DDD原著的补充和修订

### 3、该规范以《领域驱动设计精粹》（Vaughn Vernon著）为辅助材料（下称DDD精粹）

- 重点参考了书中的六边形架构、CQRS等概念
- 该规范不默认DDD精粹中的论述，需要借鉴的会完整描述

## 二、领域

### 1、领域分级

- #### 大领域

一个微服务是一个领域，如果多个概念因内容少放在一个微服务内，那就是一个复合型的大领域

- #### 领域

微服务内部的顶级业务模块，module包内每一个包就是一个领域

- #### 子领域

领域内也可以有子领域

### 2、识别领域

- 有领域服务
- 有领域实体

### 3、边界特征

- 完整性
  - 本领域的逻辑能闭环，能完整描述
- 独立性
  - 和外部领域能做到低耦合

### 4、领域的关系

- 低耦合高内聚
- 大领域需要在设计文档中列出领域边界，和明确不在边界内的相似的概念

### 5、领域与分层架构的关系

- ##### 业务相关

  - ##### 先做领域划分，再分层（API、Service、持久化等）

- ##### 业务无关

  - ##### 统一放在module领域层外部

### 6、FAQ

- #### Q：看似相关的业务逻辑设计成一个领域还是两个领域？

  - 【分而治之原则】，如果变成两个之后，能设计成低耦合的关系，则设计成两个领域
  - 每个领域是独立而逻辑完整的



## 三、重要架构点说明

### 1、DDD概念

- #### 实体

  - 需要存储在系统中
    - 也包含非持久化存储，如登录Token信息
  - 实体有状态
    - 最简化也有是否有效的状态
  - 不包含聚合，让领域服务设计更简单

- #### VO

  - VO是瞬时对象，常用的对象，或作为实体的内容的一部分

### 2、【适配层架构原则】

- 与二方服务交互必须经过适配

- 与三方服务交互必须经过适配

- 二方/三方变化时，module领域层不需要变化

- #### 六边形架构

  - api层是输入端口适配，业务相关，属于领域层
  - dao层是持久化端口适配，业务相关，属于领域层-实现层
  - mq消息输入输出端口适配，业务相关，属于领域层
  - adapter适配层是与二方服务/三方服务的交互适配，在领域层外部

### 3、【CQRS原则】

- 命令与查询指责分离
  - 领域服务拆分为领域命令服务和领域查询服务
  - api层也分为命令api和查询api
- 命令
  - 会改变系统实体状态的操作
  - 命令代表核心逻辑，分离关注点，重点维护
- 查询
  - 安全的，不会改变任何实体的状态

### 4、【应用端细分原则】

- api接口层，需要按照应用端细分，如C端，admin端，system系统端，open三方端，广告主端，媒体端等

### 5、状态机

- 状态机，是【显式设计原则】和【所见即所得原则】最佳实践
- 状态机能显而易见的帮助简化复杂的状态转化逻辑

## 四、与DDD原著的差异点

### 1、选择贫血模型，而不是充血模型

- 数据与操作分离
- 实体都是数据
- 所有的操作都在领域服务中
- 贫血模型是DDD最佳实践

### 2、如何处理聚合逻辑

- 实体不聚合
- VO可以很灵活
- 不引入“聚合根”概念
- 领域服务可以聚合（调用其他领域服务）

### 3、为什么没有应用层

- DDD原著中应用层解决两个问题：问题1是连接api层和领域层，问题2是帮助领域间形成聚合调用
- 参考【领域隔离原则】，问题1已经不存在，api层属于领域层，直接调用领域服务
- 针对问题2，聚合逻辑仅存在于领域服务，两个解决方案
  - 相关逻辑可以归于更相关的领域服务
  - 单独建立一个只有服务没有实体的领域，可以调用其他多个领域
- 我们的选择：简化概念，去掉模糊

### 4、为什么不选择基础设施层

- DDD原著中基础设施层的定义，未强调业务无关性，如持久化层和发送通知例子中，都包含业务相关逻辑
- 业务相关逻辑如果放在领域层外部，不符合【领域隔离原则】
- 如，持久化层分为“业务相关持久化实现”和“业务无关持久化组件”两部分
  - 按照【领域隔离原则】，“业务相关持久化实现”应该属于领域层（包含业务相关的参数组织等逻辑）
- 如，发送通知逻辑分为“业务相关发送通知代码”和“业务无关发送通知组件”两部分
  - 按照【领域隔离原则】，“业务相关发送通知代码”应该属于领域层（包含业务相关的参数组织等逻辑）
- 我们选择使用“公共组件层”+“微服务配置层”

### 5、弃用Repository概念

- 同弃用hibernate而选择mybatis的原因
- 持久化层不能承担CRUD以外的逻辑，破坏了【依赖倒置原则】
- 【所见即所得原则】，保持CRUD，不会产生意外（get，set，list等方法不会产生看起来不该有的影响）
- 我们选择dao概念，强调其CRUD属性

## 五、分层架构

> 分层依赖关系（>>）：（（领域层 >> 适配层 >> 外部服务层）>> 公共组件层）>> 微服务配置层

### 领域层

- `package: com.xxx.[业务线].[微服务包名].module`
- 所有业务相关逻辑，都在领域层，都属于某领域
- 领域层外部一行业务逻辑相关代码都不要有
- API在领域模块内部
- 主要包含：API层（外部调用的API）、MQ层、领域模型层、持久化层

#### 领域内分层

> 依赖关系（>>）：（api >> 领域模型）（impl领域实现层 >> 领域模型）

- ##### 领域模型层

  - 领域服务
    - `package: com.xxx.[业务线].[微服务包名].module.[领域名].xxxCmdService`
    - `package: com.xxx.[业务线].[微服务包名].module.[领域名].xxxQueryService`
    - 只定义接口，实现放在实现层
  - 领域实体
    - `package: com.xxx.[业务线].[微服务包名].module.[领域名].entity`
  - 领域VO
    - `package: com.xxx.[业务线].[微服务包名].module.[领域名].vo`

- ##### api接口层

  - `package: com.xxx.[业务线].[微服务包名].module.[领域名].api`
  - 对外接口（http或其他），包含用户界面相关接口（MVC的V）
  - 接口逻辑属于业务领域相关逻辑，必须放在领域层内部
  - api层只有数据转化逻辑，实际业务领域逻辑需要放在领域服务层
  - api的结果会呈现非常多样化的格式，xxxQueryService提供尽量少的格式

- ##### apiclient接口回调层

  - `package: com.xxx.[业务线].[微服务包名].module.[领域名].apiclient`
  - 本领域调用外部的回调接口，协议有本领域定

- ##### mq消息队列层

  - `package: com.xxx.[业务线].[微服务包名].module.[领域名].mq`
  - 本领域定义的消息队列，包含生产者和消费者
  - 消息队列必然属于某一个领域，须放在领域层内部
  - mq层只有数据转化逻辑，实际业务领域逻辑需要放在领域服务层

- ##### job任务层

  - `package: com.xxx.[业务线].[微服务包名].module.[领域名].job`
  - 定时/非定时的任务
  - job层只有数据调度和分片逻辑，实际业务领域逻辑需要调用XxxCmdService

- ##### impl领域实现层

  - `package: com.xxx.[业务线].[微服务包名].module.[领域名].impl`
  - 领域服务的实现，完全不能给领域外部访问

- ##### dao持久化层

  - `package: com.xxx.[业务线].[微服务包名].module.[领域名].impl`
  - 不承担CRUD外的职责（包含不能写死任何常量），沿用dao这个名称
  - 数据访问属于领域服务的实现的一部分，须放在impl领域实现层内部

### 适配层

- `package: com.xxx.[业务线].[微服务包名].adapter`
- 参考“六边形架构”
- 原则：二方/三方服务协议发生变更，module内主逻辑无需变动
- 针对独立微服务组件，所有二方/三方服务（其他组件提供的api/apiCallback），必须经过适配，才能使用

### 外部服务层

- 二方服务层
  - `package: com.xxx.[业务线].[微服务包名].second`
  - 所有二方服务/MQ的逻辑都在second层的某二方领域内
  - second内的XxxReq/XxxResp类，接口，MQ等命名，与二方服务的api文档完全保持一致
  - 本微服务module内不能直接调用second封装的api，必须经过adapter包内的适配器调用
- 三方服务层
  - `package: com.xxx.[业务线].[微服务包名].third`
  - 所有三方服务/MQ的逻辑都在second层的某三方领域内
  - third内的XxxReq/XxxResp类，接口，MQ等命名，与三方服务的api文档完全保持一致
  - 本微服务module内不能直接调用third封装的api，必须经过adapter包内的适配器调用

### 公共组件层

- `package: com.xxx.[业务线].[微服务包名].component`
- 100%业务领域无关的公共组件，可以给其他领域或者模块调用
- 包含
  - 本地公共组件：对某个中间件、技术点，通用的方法的封装
  - 外部公共组件：对集群中的公共服务的本地封装

### 微服务配置层

- config配置层
  - `package: com.xxx.[业务线].[微服务包名].config`
  - 只存放配置类
  - 项目所有配置类都必须放到这个包中
  - 配置中使用的有公共逻辑处理的类请放到component包中，不能放在config包中
  - 切面实现的类请放在aop切面层中
- aop切面层
  - `package: com.xxx.[业务线].[微服务包名].aop`
  - 全局切面处理的逻辑，都放这里
  - 如果有业务领域逻辑请封装到module包，并在aop类中调用
- consts常量定义包
  - `package: com.xxx.[业务线].[微服务包名].consts`
  - 某实体相关的状态常量和类型常量，定义在实体类内部
  - 某领域内不常量优先定义在各领域内的consts包内
  - 其他常规的如ErrorCode可以统一定义在consts内
- common公共类包
  - `package: com.xxx.[业务线].[微服务包名].common`
  - 纯技术类库，不包含任何业务领域逻辑
  - 包含业务领域逻辑的纯类库（静态方法等），请放在相应的领域层内部
  - 需要注入或配置才能使用的组件，请放到component公共组件层

### 示例

```CSS
com.xxx.[业务线].[微服务包名]
  .module
    .[业务领域名xxx]
      .XxxCmdService    /*唯一命令入口*/
      .XxxQueryService    /*唯一查询入口*/
      .entity    /*实体定义包*/
      .vo    /*值对象包*/
      .impl
        .dao    //
  .component
    .[组件领域名]
      .XxxService
  .adapter
    .[适配领域名]
  .second
    .[二方服务名]
      .XxxApiClient
      .XxxApiCallback
      .mq
        .XxxMqConsumer
  .third
    .[三方服务名]
  .aop
    .auth
    .[其他切面包]
  .config
    .XxxConfig
  .consts
    .[常量类/接口]
  .common
    .util
    .[其他公共类/包]
```



## 六、设计规范辅助工具

### 1、Java脚手架

- #### 微服务工程脚手架

  - 自动生成工程项目代码包，落实分层架构package结构，包含各分层规范文档
  - 包含微服务配置层主要代码
  - 包含公共组件层主要代码

- #### 领域模块脚手架

  - 自动生成某领域层代码包，落实分层架构之领域内分层



## 附录1、强制设计原则：

### 【所见即所得原则】

- 第一层，强调类，方法，接口，参数等名称，和实际内容必须一致，不能口语话，不能有二义性
- 第二层，设计层面，设计文档和代码，设计图和代码，要所见即所得，例如状态机模式
- 第三层，不要过度抽象，过度抽象的概念会导致，所见和所得之间隔着很多不显而易见的场景、条件

### 【代码量忽略原则】

- 写代码的时间，远远小于设计和查找问题和重构的时间
- 看似相同的代码也许只是碰巧，公共代码也许带来强耦合，慎用抽象类

### 【奥卡姆剃刀原则】

- 第一层，当前用不到的元素不添加
- 第二层，不过度设计

### 【显式设计原则】

- 重要的逻辑，必须有明确的设计体现，而不是隐藏带代码逻辑里，如状态机
- 例子：判断Manager

### 【分而治之原则】

- 相关的逻辑，如果分模块设计之后，能保持低耦合，则应该分开模块

### 【领域隔离原则】

- 所有逻辑分为业务相关，和业务无关。
- 业务无关逻辑，划分到领域层外部
- 业务相关逻辑，必然属于领域层，必然先划分到某一领域，如api层和dao层都在领域内部

### 【长短期方案原则】

- 设计方案，先按照最合理的方式做，现状设计不影响这个方案，现状设计只影响实现这个方案的步骤（短期方案）

### 【依赖倒置原则】

- 分层之间一刀切单向依赖，package包级别
- 低层模块不应该依赖高层模块
- 抽象不应该依赖细节；细节应该依赖抽象
- 针对接口编程，不要针对实现编程