# 延时任务的设计

## 一、基本概念

什么是延时队列?首先它要具有队列的特性，再给它附加一个延迟消费队列消息的功能，延迟队列相对比普通队列，区别就在**延时**的特性上，普通队列先进先出，按入队顺序进行处理，而延时队列中的元素在入队时会指定一个延时时间，希望能够在指定时间到了以后处理。

## 二、使用场景

业务类场景:

1、支付订单成功后，指定时间以后将支付结果通知给接入方。
2、淘宝订单业务:下单之后如果三十分钟之内没有付款就自动取消订单。
3、美团或饿了吧订餐通知:下单成功后60s之后给用户发送短信通知。
4、会议预定系统，在预定会议开始前半小时通知所有预定该会议的用户。
5、IT问题工单超过24小时未处理，则自动拉企微群提醒相关责任人。
6、用户下单外卖以后，距离超时时间还有10分钟时提醒外卖小哥即将超时。

技术框架场景:

1、关闭空闲连接。服务器中，有很多客户端的连接，空闲一段时间之后需要关闭之。
2、缓存。缓存中的对象，超过了空闲时间，需要从缓存中移出。
3、任务超时处理。在网络协议滑动窗口请求应答式交互时，处理超时未响应的请求等。
·····
都可以用延时队列实现。

## 三、实现方案

1、定时任务轮询数据库
2、Java提供的DelayQueue
3、netty提供的时间轮算法实现类HashedWheelTimer
4、消息中间件(rabbitmq、rocketmq、kafka)延迟消息
5、Redis的sorted set或redis key过期回调

## 四、实现落地

### 1、定时任务轮询数据库

采用定时任务实现延迟，对业务表进行轮询判断，订单到点执行，有一点点误差。实现如下:

1)使用单机版的spring schedued+分布式锁（也可以写一个定时服务，这样集群也会保证同一时间只有一个任务执行），代码如下:

```java
@Slf4j
@Configuration
@EnableScheduling
public class OrderAutoCancelSpringJob {
    @Resource
    private DistributeLockHelper distributeLockHelper;
    private static final String ORDER_AUTO_CANCEL_LOCK = "orderAutoCancelLock";

    @Scheduled(cron = "0/60 * * * *?")
    public void cancelorder() {
        if (!distributeLockHelper.tryLock(ORDER_AUTO_CANCEL_LOCK, TimeUnit.MINUTES, 1)) {
            return;
        }
        try {
            //执行业务逻辑
        } finally {
            distributeLockHelper.unlock(ORDER_AUTO_CANCEL_LOCK);
        }
    }
}
```

2)优缺点

**优点:**

- 简单易行，支持集群操作

**缺点:**

- 对服务器内存消耗大
- 存在延迟，比如你每隔 3 分钟扫描一次，那最坏的延迟时间就是 3 分钟
- 假设你的订单有几千万条，每隔几分钟这样扫描一次，数据库损耗极大

3)适用场景

该方案在互联网应用还是比较广泛的，适合定实时性要求没那么精确，允许有一点误差的场景。

### 2、Java提供的DelayQueue

1)DeLayQueue是什么及实现原理?
DeLayQueue是JDK提供的一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。 这种队列是有序的，即队头对象的延迟到期时间最长。注意:不能将null元素放置到这种队列中。

2)实现注意事项
队列元素需要实现Delayed接口， getDelay方法用于设置延迟时间，compareTo方法用于对队列中的元素进行排序。

入队:
put()、offer()，线程安全。

出队：
poll()，非阻塞方式获取，没有到期的元素直接返回null。
take()，阻塞方式获取，没有到期的元素线程将会等待。

3)优缺点

**优点：**

- 效率高,任务触发时间延迟低。

**缺点：**

- 服务器重启后，数据全部消失，怕宕机
- 集群扩展相当麻烦
- 因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现 OOM 异常
- 代码复杂度较高

4)适用场景
适用于不需要持久化任务量少的单机任务，能容忍丢失。

代码参考：https://juejin.cn/post/6844904150703013901

### 3、netty提供的时间轮算法实现类HashedWheelTimer

1)时间轮算法是任么及实现原理？

时间轮算法，参考的时钟，从时钟中得到的一些启发设计出来的，简单的讲它是一个存储定时任务的环形队列，底层采用数组实现，数组中的每个元素可以存放一个延时任务列表。延时任务列表是一个双向链表，链表中的每一项表示的都是一个延时任务。

2)常见实现方案

以 netty 的 HashedWheelTimer 为例，算法规则如下：

假设共有八个槽 0~7，槽的时间单位为 1 秒

现在要加入一个延时 5 秒的任务，计算方式就是 5%8+1=6，即放在槽位为 6，下标为 5 的那个槽中。

假如要加入一个延时 50s 的任务，计算方式就是 50%8+1=3，即应该放在槽位是 3，下标是 2 的位置。但是记住这里有轮次的概念， 轮次=(50-1)/8=6，即轮数记为6。也就是说当循环6轮之后扫到下标的2的这个槽位会触发这个任务。

对于延迟超过时间轮所能表示的范围有两种处理方式：

一是通过增加一个字段-轮数，Netty 就是这样实现的。

二是多层次时间轮，Kafka：是这样实现的，跟我们的手表非常像，像我们秒针走一圈，分针走一格，分针走一圈，时针走一格。相比而言 Netty 的实现会有空推进的问题，而 Kafka 采用 DelayQueuel 以槽为单位，利用空间换时间的思想解决了空推进的问题。

它们的任务插入和删除时间复杂度都为 0 (1) 

3)优缺点

**优点**：只需要一个线程推进时间轮，查询效率高，性能相对好一些。效率高,任务触发时间延迟时间比 delayQueue 低，代码复杂度比 delayQueue 低。

**缺点**：

- 服务器重启后，数据全部消失，怕宕机
- 集群扩展相当麻烦
- 因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现 OOM 异常

4)适用场景

适用于对时效性不高的，可快速执行的小任务，能够做到高性能，低消耗。

应用的场景：心跳检测（客户端探活）会话、请求是否超时消息延迟推送

### 4、消息中间件(rabbitmq、rocketmq、kafka)延迟消息

1）常见的实现方案 rocketmq

rocketmq 先把消息按照延时时间段发到指定的队列中，然后通过一个定时器轮询这些队列，查看消息是否到期，如果到期就把这个消息发到指定的 topic 队列，流程图如下所示：

基于 rocketmg：

实现延时队列原理注意点：

RocketMQ延时消息的延迟时长不支持随意时长的延迟，是通过特定的延迟等级来指定的。默认支持 18 个等级的延迟消息。

延时等级定义在 RocketMQ 服务端的 MessageStoreConfig 类中的如下变量中：

private String messageDelayLevel  = "1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h";

发消息时，设置 delayLevel 等级即可：msg. SetDelayLevel (level)
level 有以下三种情况：

Level==0，消息为非延迟消息

1 <= level <= maxLeveL，消息延迟特定时间，例如 Level==1, 延迟 1s 

level> maxLevel，则 Level== maxLevel，例如 Level==20, 延迟 2h 

注意：如果希望支持超过 2h 的延时消息，需要修改时间配置和对应的 Level 

kafka不支持延时方案。

2）优缺点

优点：

基于消息中间件可以快速实现延时队列，而且天然支持消息消费的有序性、消息持久化、AK 机制等。

缺点：

没有接入上面中间件的团队，需要额外引入、增加了部署和运维成本。

3）适用场景

一般大厂的方案，适用于大量延时任务的场景。



### 5、Redis的sorted set、redis key过期回调、redisson的api

参考文章：https://segmentfault.com/a/1190000042207069?sort=newest

https://www.cnblogs.com/better-farther-world2099/articles/15216447.html



优点：支持持久化，分布式

缺点：缺少ack机制，如果任务执行失败任务就丢了



使用场景：

对任务顺序要求不高，允许丢失，例如延迟通知场景。