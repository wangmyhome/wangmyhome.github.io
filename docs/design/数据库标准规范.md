# 数据库标准规范

## 1、目的

此文档通过明确数据库使用约束及建议，旨在标准化数据库使用规范，为团队研发工作提供指导，以提升产品质量。

## 2、 适用范围和修改权限

### 2.1、适用范围

XXX各研发团队

### 2.2、修改权限

平台研发部-互联网运维部

## 3、约束级别说明

![img](img/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E6%A0%87%E5%87%86.jpg)

【禁止】：即不允许，违反该条规范的行为，必定带来严重后果，且代码审核不会通过；

【不推荐】：违反该条规范的行为，通常会产生严重问题，且代码审核可能不通过；如坚持使用，需和DBA沟通后再决策；

【参考】：即建议，可以选择，可以不选择，使用者可根据具体使用场景决策；

【推荐】：是一种成熟的建议，如果没有更好的方案，遵照该条规范会是不错的选择；

【强制】：此条规范必须遵守，这是技术委员会和行业经验共同决策为最好的处理方式；

## 4、命名规范

### 4.1、基本规范

【禁止】禁止使用MySQL关键字

【禁止】禁止使用数字开头

【不推荐】不推荐使用复数名词

【不推荐】不推荐使用拼音

【推荐】推荐使用的字符：ASCII: [0-9,a-z,_]

【推荐】建议全部使用小写字母

【推荐】建议使用富有意义的英文词汇，单词之间通过下划线分隔

【推荐】建议命名长度不超过32个字符，且命名遵循见名知意的原则

### 4.2、表命名

【强制】数据库临时表必须以 tmp_ 为前缀，且以日期(格式：20190917) 为后缀；备份表必须以 bak_ 为前缀，且以日期为后缀；示例如下：

​	`a. tmp_<tablename>_20190917`

​	`b. bak_<tablename>_20190917`

【强制】数据库中不允许长期保留备份表

【推荐】存储相同数据的列名和列类型建议保持一致

### 4.3、索引命名

【参考】主键索引名建议以 pk_ 为前缀

【参考】唯一索引名建议以 uk _为前缀

【参考】普通索引名建议以 idx _为前缀

>  pk_ 即 primary key；
>
>  uk _ 即 unique key；
>
>  idx _ 即index 的简称；

## 5、设计规范

### 5.1、基本规范

【不推荐】不建议在数据库做运算，计算移至业务层

【不推荐】拒绝3B (拒绝大sql语句：big sql、拒绝大事物：big transaction、拒绝大批量：big batch)

【强制】创建数据库时必须显式指定字符集，并且字符集只能是utf8mb4

【强制】建表时一律采用Innodb存储引擎

【强制】表和字段必须添加注释，如果修改字段，需要及时更新字段注释

【推荐】表的字符集建议使用utf8mb4，默认继承库字符集

【参考】数据库设计时，可以在范式和冗余间做平衡，如果选择效率优先，往往会牺牲范式

### 5.2、字段设计

【禁止】禁止使用TEXT、BLOB数据类型，如需使用，需DBA评估后决策

【禁止】禁止设置预留字段

【不推荐】日期类型不建议使用字符串存储

【强制】所有列定义为NOT NULL，并且有默认值（0，'','1970-01-01'）

【推荐】优先选择符合存储需要的最小数据类型

【推荐】数字类型的定义，后面不跟显示长度

【推荐】不使用char，用varchar代替

【推荐】char和varchar定义的存储空间够用即可

【推荐】小数的存储，建议使用decimal数据类型，注意小数精度留足；小数的存储，也可以转换为整数通过放大/缩小来展示，或将数据拆成整数和小数分开存储

【推荐】字段数不超过30，行长不超过65535，尽量满足冷热数据分离，减小表宽度

【推荐】字段允许适当冗余，以提高查询性能，但必须考虑到数据的一致性。冗余字段应遵循以下原则：

> ​      a. 不是频繁修改的字段
>
> ​      b. 不是varchar超长字段
>
> ​      c. 不是text字段
>
> ​      例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询

【推荐】单表行数超过1000万或单表容量超过10GB 时，可以考虑分库分表

​      说明：三年后的数据量，如预计达不到以上级别，不要在创建表时分库分表

【强制】表示不同语言含义的字段，字段名需加上后缀，例如表示中文：xxx_zhcn,表示英文：xxx_enus。

### 5.3、索引设计

【禁止】禁止使用外键

【禁止】禁止出现冗余索引

【强制】每个Innodb 表必须有一个主键，且无业务含义，主键定义如下：

> a. id int unsigned NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT 'PRIMARY KEY',
>
> b. 有疑问可以参考文章：《表的主键应当不具有任何业务含义整理》https://blog.csdn.net/cxzhq2002/article/details/4435267
>

【推荐】每张表的索引数量是 min(5，列总数 * 20%)

【推荐】复合索引的字段数不超过5个

【推荐】多表关联查询时，被关联的字段需要有索引

【推荐】数据唯一性由程序保证，数据库中的唯一约束(unique)仅保证数据完整性而无业务意义

### 5.4、参数设计

DBA在创建数据库实例时，参数需按照如下规范设置：

【强制】character-set-server = utf8mb4

【推荐】binlog_format = row

【推荐】slow_query_log = on

【推荐】sql_mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION";

【推荐】interactive_timeout = 600

【推荐】wait_timeout = 600

## 6、SQL规范

【禁止】程序中，杜绝使用SELECT * ，必须使用SELECT <字段列表> 查询

【禁止】禁止使用不含字段列表的INSERT 语句

【禁止】禁止不同数据类型连接，从而避免隐式转换，请使用相同数据类型进行匹配

【禁止】禁止使用having

【禁止】禁止使用order by rand() 进行随机排序

【禁止】禁止使用的SQL语句

>    a. 禁用update|delete t1 … where a=XX limit XX; 这种带limit的更新语句。
>
> ​    因为会导致主从不一致，导致数据错乱。建议加上order by PK。
>
>    b. 禁止使用关联子查询，效率极其低下。
>
> ​    如update t1 set … where name in(select name from user where…);
>
>    c. 禁用procedure、function、trigger、views、event、外键、check约束。
>
> ​    因为他们消耗数据库资源，降低数据库实例可扩展性。推荐在程序端实现。
>
>    d. 禁用insert into …on duplicate key update…在高并发环境下，会造成主从不一致。
>

【不推荐】不推荐使用 count( 列名 ) 或 count( 常量 ) ，建议使用 count( * ) 

【不推荐】避免使用JOIN或UNION关联超过3张表

【不推荐】避免使用子查询，可以把子查询优化为JOIN关联操作

【不推荐】不建议在WHERE从句中对列进行函数转换和计算

【强制】Updata/Delete语句必须有WHERE条件

【推荐】在使用JOIN时，被关联的字段数据类型需要一致，且需要有索引

【推荐】在明显不会有重复值时，使用UNION ALL 而不是UNION

【推荐】对同一列对象进行or 判断时，使用in 替代or，in值不超过200

【推荐】对于连续数值，使用 BETWEEN 不用 IN，例如：SELECT id FROM t WHERE num BETWEEN 1 AND 5

【推荐】建议把复杂、较长的SQL 拆分为多个小SQL

【推荐】程序中数据的批量操作(update delete insert)，分多次进行，每批次不超过500条

【推荐】应用程序需捕获SQL异常，并有相应处理

【参考】建表语句不要出现DROP TABLE IF EXISTS 判断字句

【参考】充分利用表中的索引，可遵循如下原则：

>    a. 在模糊查询中，使用前缀确定的格式： xxx%
>
>    b. 在使用联合索引时，查询需含索引首列
>
>    c. 使用not exists 代替not in
>
>    d. 避免负向查询：NOT、!=、<>、!<、!>、NOT IN、NOT LIKE、NOT Exists等
>

## 7、行为规范

【禁止】禁止在生产库上做压力测试

【禁止】禁止从开发环境、测试环境直接连接生产环境数据库

【禁止】禁止跨库查询，程序连接不同的数据库使用不同的账号，目的如下：

>    a. 为数据库迁移和分库分表留出余地
>
>    b. 降低业务耦合度
>
>    c. 避免权限过大而产生的安全风险
>

 【禁止】未经审批，生产库数据禁止导出

 【不推荐】不建议在主库上执行统计类的功能查询，这种复杂类的SQL会造成CPU的升高，进而会影响业务

 【不推荐】一个MySQL实例不要存放多个业务数据库，会造成业务耦合性过高，一旦出现问题会殃及池鱼，增加了定位故障问题的难度。通常采用多实例解决，一个实例一个业务库，互不干扰

 【不推荐】数据库账号不推荐使用弱密码，应该包含字母数字特殊字符组合，字母含大小写，长度不小于8位

 【推荐】对于程序连接数据库账号，遵循权限最小原则

>    a. 数据库账号1对1
>
>    b. 生产库、预发、测试库放在不同实例中
>
>    c. 账号权限：
>
> ​    1. 生产、预发环境——赋予增、删、改、查的权限，并做库表级限制，如有特殊需求，需评估和审批
>
> ​    2. 测试环境——赋予最大权限
>

【推荐】数据安全方面，数据需要脱敏后存储，内容摘要如下：

>    a. 禁止数据库、日志文件中明文存储用户密码、银行卡卡号、身份ID、手机号、CVV、详细地址、生物指纹认证token等交易敏感数据。
>
>    b. 禁止使用不安全算法,存储用户身份校验凭据，如：密码。会员系统、支付系统还应在此基础上进一步增强安全措施。



【参考】程序层DAO设计建议，仅供参考：

   a. 前端程序报错里尽量能够提示MySQL原生态的报错信息，便于排查错误。

   b. 程序连接MySQL，必须要有连接超时和失败重连机制，且失败重试必须有间隔时间。

   c. 对于有连接池的前端程序，必须根据业务需要配置初始、最小、最大连接数，超时时间以及连接回收机制，否则会耗尽数据库连接资源，造成线上事故。

   d. 对于log或history类型的表，随时间增长容易越来越大，因此上线前，必须建立表数据清理或归档方案。

   e. 多个并发业务逻辑访问同一块数据（innodb表）时，会在数据库端产生行锁甚至表锁导致并发下降，因此建议更新类SQL尽量基于主键去更新。

   f. 业务逻辑之间加锁顺序尽量保持一致，否则会导致死锁。

   g. 对于单表读写比大于10:1的数据行或单个列，可以将热点数据放在缓存里，加快访问速度，降低MySQL压力。

## 8、附录

### 8.1、关键字

MySQL关键字，请参考官方文档

   1. 5.6版 https://dev.mysql.com/doc/refman/5.6/en/keywords.html

   2. 5.7版 https://dev.mysql.com/doc/refman/5.7/en/keywords.html

   3. 8.0版 https://dev.mysql.com/doc/refman/8.0/en/keywords.html

### [8.2、为什么建议MySQL列属性尽量用 NOT NULL](https://www.cnblogs.com/better-farther-world2099/articles/12170299.html)

<https://www.cnblogs.com/better-farther-world2099/articles/12170299.html>

<https://segmentfault.com/a/1190000039774659>

<https://www.techug.com/post/you-should-not-use-null-in-mysql.html>



